package com.paytm.digital.education.form.service.impl;

import com.paytm.digital.education.form.model.FormData;
import com.paytm.digital.education.form.model.FormStatus;
import com.paytm.digital.education.form.model.LatestFormData;
import com.paytm.digital.education.form.service.SaveAndFetchService;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.data.domain.Sort;
import org.springframework.data.mongodb.core.MongoOperations;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.data.mongodb.core.query.Update;
import org.springframework.lang.NonNull;
import org.springframework.stereotype.Service;

import javax.validation.constraints.NotBlank;
import java.util.Date;
import java.util.List;
import java.util.Objects;

@AllArgsConstructor
@Service
@Slf4j
public class SaveAndFetchServiceImpl implements SaveAndFetchService {

    private MongoOperations mongoOperations;

    /*
     **
     * The function takes two arguments:
     * 1. formData: Data entered from form
     * 2. confirmFlag: To change the state to PAYMENT_PENDING
     *
     * And returns an id in response
     *
     * This function does the following:
     *  -> If the no data is present against provided merchantId, customerId and candidateId
     *       it will save a new record and return _id generated by mongodb
     *  -> If a record is present and the status is REGISTERED then it will update the status to PARTIAL
     *  -> If the status is PARTIAL and confirmFlag is false then it will only update the record
     *  -> If the status is PARTIAL and confirmFlag is true then it update the status to PAYMENT_PENDING
     *  -> If the status is PAYMENT_PENDING then the status is updated to PARTIAL and data is updated
     *  -> If the status is SUCCESS, PENDING or FAILURE the status is updated to PARTIAL and new document is saved
     *  -> ADDONS status is treated same as the PAYMENT_PENDING
     */

    @Override
    public String saveData(FormData formData, boolean confirmFlag) {

        FormData data = null;
        if (Objects.nonNull(formData.getId())) {
            data = getRecord(formData.getId());
        } else {
            data = getLatestRecord(formData.getMerchantId(), formData.getCustomerId(),
                    formData.getCandidateId());
        }
        if (Objects.isNull(data)) {
            formData.setCreatedAt(new Date());
            formData.setUpdatedAt(new Date());
            formData.setStatus(FormStatus.REGISTERED);
            return mongoOperations.save(formData).getId();
        } else {
            FormStatus status = data.getStatus();
            String id = null;
            switch (status) {
                case SUCCESS:
                case PENDING:
                case FAILURE:
                case PG_PAYMENT_DONE:
                    formData.setId(null);
                    formData.setCreatedAt(new Date());
                    formData.setUpdatedAt(new Date());
                    formData.setStatus(FormStatus.REGISTERED);
                    return mongoOperations.save(formData).getId();
                case REGISTERED:
                case PAYMENT_PENDING:
                    id = validateAndUpdateFormData(data, formData, FormStatus.PARTIAL);
                    break;
                case PARTIAL:
                    if (!confirmFlag) {
                        id = validateAndUpdateFormData(data, formData, null);
                    } else {
                        // Originally we were not updating details in this case
                        id = validateAndUpdateFormData(data, formData, FormStatus.PAYMENT_PENDING);
                    }
                    break;
                case ADDONS:
                    // Originally we were not updating details in this case
                    id = validateAndUpdateFormData(data, formData, null);
                    break;
                default:
                    id = data.getId();
            }
            if (Objects.isNull(id)) {
                log.error("Form detail validation failed.");
            }
            return id;
        }

    }

    public String saveDataOld(FormData formData, boolean confirmFlag) {

        FormData data = getFormDataFromDB(formData);

        String id = null;

        if (data == null) {
            // todo: handle race condition
            formData.setCreatedAt(new Date());
            formData.setUpdatedAt(new Date());
            formData.setStatus(FormStatus.REGISTERED);

            id = mongoOperations.save(formData).getId();
        } else {
            FormStatus status = data.getStatus();

            switch (status) {
                case SUCCESS:
                case FAILURE:
                case PENDING:
                    // throw exception bad request

                    formData.setCreatedAt(new Date());
                    formData.setUpdatedAt(new Date());
                    formData.setStatus(FormStatus.PARTIAL);

                    id = mongoOperations.save(formData).getId();
                    break;

                case REGISTERED:
                    formData.setMerchantId(data.getMerchantId());

                    data.setCandidateDetails(formData.getCandidateDetails());
                    data.setAdditionalData(formData.getAdditionalData());
                    data.setUpdatedAt(new Date());
                    data.setStatus(FormStatus.PARTIAL);
                    if (formData.getTransactionType() != null) {
                        data.setTransactionType(formData.getTransactionType());
                    }

                    // todo: what if id is null ?
                    if (formData.getMerchantCandidateId() != null) {
                        data.setMerchantCandidateId(formData.getMerchantCandidateId());
                    }

                    updateData(data, false);
                    id = data.getId();
                    break;

                case PARTIAL:
                    if (!confirmFlag) {
                        data.setCandidateDetails(formData.getCandidateDetails());
                        data.setAdditionalData(formData.getAdditionalData());
                        data.setUpdatedAt(new Date());
                        data.setStatus(FormStatus.REGISTERED);

                        if (formData.getTransactionType() != null) {
                            data.setTransactionType(formData.getTransactionType());
                        }

                        if (formData.getMerchantCandidateId() != null) {
                            data.setMerchantCandidateId(formData.getMerchantCandidateId());
                        }

                        updateData(data, false);
                        id = data.getId();
                    } else {
                        data.setStatus(FormStatus.PAYMENT_PENDING);
                        data.setUpdatedAt(
                                new Date()); // todo: do mongo provide set current date on update ?

                        updateData(data, false);
                        id = data.getId();
                    }
                    break;

                case ADDONS:
                    data.setAdditionalData(formData.getAdditionalData());
                    break;

                case PAYMENT_PENDING:
                    data.setStatus(FormStatus.PARTIAL);
                    data.setUpdatedAt(new Date());
                    data.setCandidateDetails(formData.getCandidateDetails());

                    updateData(data, false);
                    id = data.getId();
                    break;

                default:
            }
        }
        return id;
    }


    /*
     **
     * This function is to be integrated with payment posting if used.
     */
    @Override
    public String paymentUpdate(FormData formData, FormStatus successFlag) {

        FormData currentData = getFormDataFromDB(formData);

        FormStatus status = currentData.getStatus();
        String id = null;

        switch (status) {
            case PAYMENT_PENDING:
                formData.setStatus(FormStatus.PG_PAYMENT_DONE);
                formData.setUpdatedAt(new Date());

                updateData(formData, true);
                id = formData.getId();
                break;

            case PG_PAYMENT_DONE:

                formData.setUpdatedAt(new Date());
                formData.setStatus(successFlag);

                updateData(formData, true);
                id = formData.getId();

                break;

            default:
        }

        return id;
    }

    private void updateData(FormData formData, boolean fulfilmentFlag) {
        Query query = new Query();
        Criteria criteria = Criteria.where("_id").is(formData.getId());
        query.addCriteria(criteria);

        Update update = new Update();
        update.set("status", formData.getStatus());
        update.set("updatedAt", formData.getUpdatedAt());
        if (formData.getTransactionType() != null) {
            update.set("transactionType", formData.getTransactionType());
        }

        if (formData.getMerchantCandidateId() != null) {
            update.set("merchantCandidateId", formData.getMerchantCandidateId());
        }

        if (fulfilmentFlag) {
            update.set("formFulfilment", formData.getFormFulfilment());

        } else {
            update.set("candidateDetails", formData.getCandidateDetails());
        }

        if (formData.getAdditionalData() != null) {
            update.set("additionalData", formData.getAdditionalData());
        }

        // todo: handle race condition, reject update if upated_at changed
        mongoOperations.updateFirst(query, update, FormData.class);
    }

    @Override
    public String saveDataWithAddon(FormData formData) {

        FormData data = getFormDataFromDB(formData);

        if (data == null) {
            return null;
        }

        data.setStatus(FormStatus.ADDONS);
        data.setAdditionalData(formData.getAdditionalData());
        data.setUpdatedAt(new Date());
        data.setCandidateDetails(formData.getCandidateDetails());

        String id = data.getId();

        updateData(data, false);

        return id;
    }

    @Override
    public FormData getLatestRecord(@NotBlank String merchantId, @NotBlank String customerId,
            @NotBlank String candidateId) {
        Query query = new Query();
        Criteria criteria = Criteria.where("merchantId").is(merchantId)
                .and("customerId").is(customerId)
                .and("candidateId").is(candidateId);
        query.addCriteria(criteria);
        query.with(Sort.by("createdAt").descending());

        return mongoOperations.findOne(query, FormData.class);
    }

    @Override
    public FormData getRecord(String refId) {
        Query query = new Query();
        Criteria criteria = Criteria.where("_id").is(refId);
        query.addCriteria(criteria);

        return mongoOperations.findOne(query, FormData.class);
    }

    private String validateAndUpdateFormData(FormData dbData, FormData externalData,
            FormStatus status) {
        if (Objects.nonNull(externalData.getCandidateId())
                && !externalData.getCandidateId().equals(dbData.getCandidateId())) {
            return null;
        }
        if (Objects.nonNull(externalData.getMerchantId())
                && !externalData.getMerchantId().equals(dbData.getMerchantId())) {
            return null;
        }
        if (Objects.nonNull(externalData.getCustomerId())
                && !externalData.getCustomerId().equals(dbData.getCustomerId())) {
            return null;
        }
        dbData.setCandidateDetails(externalData.getCandidateDetails());
        dbData.setAdditionalData(externalData.getAdditionalData());
        dbData.setUpdatedAt(new Date());
        dbData.setStatus(status);
        if (externalData.getTransactionType() != null) {
            dbData.setTransactionType(externalData.getTransactionType());
        }

        // todo: what if id is null ?
        if (externalData.getMerchantCandidateId() != null) {
            dbData.setMerchantCandidateId(externalData.getMerchantCandidateId());
        }
        updateData(dbData, false);
        return dbData.getId();
    }

    private FormData getFormDataFromDB(FormData formData) {
        FormData data = null;

        if (Objects.nonNull(formData.getId())) {
            data = getRecord(formData.getId());

        } else if (StringUtils.isNotBlank(formData.getCustomerId())
                && StringUtils.isNotBlank(formData.getMerchantId())
                && StringUtils.isNotBlank(formData.getCandidateId())) {
            data = getLatestRecord(formData.getMerchantId(), formData.getCustomerId(),
                    formData.getCandidateId());
        }

        return data;
    }

    public boolean validateFormDataRequest(FormData formData) {
        return Objects.nonNull(formData.getId())
                || (StringUtils.isNotBlank(formData.getMerchantId())
                && StringUtils.isNotBlank(formData.getCustomerId())
                && StringUtils.isNotBlank(formData.getCandidateId()));
    }

    private FormData getFormDataBasedOnCriteriaAndSort(
            Criteria criteria, List<String> projectionKeys, String sortField) {
        Query query = new Query();
        query.addCriteria(criteria);
        if (sortField != null) {
            query.with(new Sort(Sort.Direction.DESC, sortField));
        }
        projectionKeys.forEach(k -> query.fields().include(k));
        query.limit(1);
        List<FormData> formData = mongoOperations.find(query, FormData.class);
        return formData.isEmpty() ? null : formData.get(0);
    }

    private Criteria createBaseCriteria(
            @NonNull String merchantId,
            @NonNull String customerId,
            @NonNull String candidateId) {
        return Criteria
                .where("merchantId").is(merchantId)
                .and("customerId").is(customerId)
                .and("candidateId").is(candidateId);
    }

    @Override
    public LatestFormData getCurrentOpenAndLastPaidFormDetails(
            String merchantId, String customerId,
            String candidateId, List<String> keys) {

        String paymentFieldName = "formFulfilment.orderId";

        Criteria lastOrderCriteria = createBaseCriteria(merchantId, customerId, candidateId)
                .and(paymentFieldName).exists(true);
        //                .and(paymentFieldName).ne(null);

        //                .andOperator(
        //                        Criteria.where(paymentFieldName).exists(true),
        //                        Criteria.where(paymentFieldName).ne(null)
        //                );

        Criteria unpaidOrderCriteria = createBaseCriteria(merchantId, customerId, candidateId)
                .and(paymentFieldName).exists(false);

        // todo: check this flow
        //                .orOperator(
        //                        Criteria.where(paymentFieldName).exists(false),
        //                        Criteria.where(paymentFieldName).is(null)
        //                );

        return new LatestFormData(
                getFormDataBasedOnCriteriaAndSort(unpaidOrderCriteria, keys, "updatedAt"),
                getFormDataBasedOnCriteriaAndSort(lastOrderCriteria, keys,
                        "formFulfilment.createdDate")
        );
    }

}
