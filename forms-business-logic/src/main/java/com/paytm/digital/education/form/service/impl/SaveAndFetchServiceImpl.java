package com.paytm.digital.education.form.service.impl;

import com.paytm.digital.education.form.model.FormData;
import com.paytm.digital.education.form.model.FormStatus;
import com.paytm.digital.education.form.model.LatestFormData;
import com.paytm.digital.education.form.service.SaveAndFetchService;
import lombok.AllArgsConstructor;
import org.springframework.data.domain.Sort;
import org.springframework.data.mongodb.core.MongoOperations;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.data.mongodb.core.query.Update;
import org.springframework.lang.NonNull;
import org.springframework.stereotype.Service;

import java.util.Date;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@AllArgsConstructor
@Service
public class SaveAndFetchServiceImpl implements SaveAndFetchService {

    private MongoOperations mongoOperations;

    /*
     **
     * The function takes two arguments:
     * 1. formData: Data entered from form
     * 2. confirmFlag: To change the state to PAYMENT_PENDING
     *
     * And returns an id in response
     *
     * This function does the following:
     *  -> If the no data is present against provided merchantId, customerId and candidateId
     *       it will save a new record and return _id generated by mongodb
     *  -> If a record is present and the status is REGISTERED then it will update the status to PARTIAL
     *  -> If the status is PARTIAL and confirmFlag is false then it will only update the record
     *  -> If the status is PARTIAL and confirmFlag is true then it update the status to PAYMENT_PENDING
     *  -> If the status is PAYMENT_PENDING then the status is updated to PARTIAL and data is updated
     *  -> If the status is SUCCESS, PENDING or FAILURE the status is updated to PARTIAL and new document is saved
     *  -> ADDONS status is treated same as the PAYMENT_PENDING
     */

    @Override
    public String saveData(FormData formData, boolean confirmFlag) {

        FormData data = getFormDataFromDB(formData);

        String id = null;

        if (data == null) {
            // todo: handle race condition
            formData.setCreatedAt(new Date());
            formData.setUpdatedAt(new Date());
            formData.setStatus(FormStatus.REGISTERED);

            id = mongoOperations.save(formData).getId();
        } else {
            FormStatus status = data.getStatus();

            switch (status) {
                case SUCCESS:
                case FAILURE:
                case PENDING:
                    formData.setCreatedAt(new Date());
                    formData.setUpdatedAt(new Date());
                    formData.setStatus(FormStatus.PARTIAL);

                    id = mongoOperations.save(formData).getId();
                    break;

                case REGISTERED:
                    data.setCandidateDetails(formData.getCandidateDetails());
                    data.setUpdatedAt(new Date());
                    data.setStatus(FormStatus.PARTIAL);
                    if (formData.getTransactionType() != null) {
                        data.setTransactionType(formData.getTransactionType());
                    }

                    // todo: what if id is null ?
                    if (formData.getMerchantCandidateId() != null) {
                        data.setMerchantCandidateId(formData.getMerchantCandidateId());
                    }

                    updateData(data, false);
                    id = data.getId();
                    break;

                case PARTIAL:
                    if (!confirmFlag) {
                        data.setCandidateDetails(formData.getCandidateDetails());
                        data.setUpdatedAt(new Date());
                        data.setStatus(FormStatus.REGISTERED);

                        if (formData.getTransactionType() != null) {
                            data.setTransactionType(formData.getTransactionType());
                        }

                        if (formData.getMerchantCandidateId() != null) {
                            data.setMerchantCandidateId(formData.getMerchantCandidateId());
                        }

                        updateData(data, false);
                        id = data.getId();
                    } else {
                        data.setStatus(FormStatus.PAYMENT_PENDING);
                        data.setUpdatedAt(new Date()); // todo: do mongo provide set current date on update ?

                        updateData(data, false);
                        id = data.getId();
                    }
                    break;

                case ADDONS:
                    data.setAdditionalData(formData.getAdditionalData());
                    break;

                case PAYMENT_PENDING:
                    data.setStatus(FormStatus.PARTIAL);
                    data.setUpdatedAt(new Date());
                    data.setCandidateDetails(formData.getCandidateDetails());

                    updateData(data, false);
                    id = data.getId();
                    break;

                default:
            }
        }
        return id;
    }


    /*
     **
     * This function is to be integrated with payment posting if used.
     */
    @Override
    public String paymentUpdate(FormData formData, FormStatus successFlag) {

        FormData currentData = getFormDataFromDB(formData);

        FormStatus status = currentData.getStatus();
        String id = null;

        switch (status) {
            case PAYMENT_PENDING:
                formData.setStatus(FormStatus.PG_PAYMENT_DONE);
                formData.setUpdatedAt(new Date());

                updateData(formData, true);
                id = formData.getId();
                break;

            case PG_PAYMENT_DONE:

                formData.setUpdatedAt(new Date());
                formData.setStatus(successFlag);

                updateData(formData, true);
                id = formData.getId();

                break;

            default:
        }

        return id;
    }

    private void updateData(FormData formData, boolean fulfilmentFlag) {
        Query query = new Query();
        Criteria criteria = Criteria.where("_id").is(formData.getId());
        query.addCriteria(criteria);

        Update update = new Update();
        update.set("status", formData.getStatus());
        update.set("updatedAt", formData.getUpdatedAt());
        if (formData.getTransactionType() != null) {
            update.set("transactionType", formData.getTransactionType());
        }

        if (formData.getMerchantCandidateId() != null) {
            update.set("merchantCandidateId", formData.getMerchantCandidateId());
        }

        if (fulfilmentFlag) {
            update.set("formFulfilment", formData.getFormFulfilment());

        } else {
            update.set("candidateDetails", formData.getCandidateDetails());
        }

        if (formData.getAdditionalData() != null) {
            update.set("additionalData", formData.getAdditionalData());
        }

        // todo: handle race condition, reject update if upated_at changed
        mongoOperations.updateFirst(query, update, FormData.class);
    }

    @Override
    public String saveDataWithAddon(FormData formData) {

        FormData data = getFormDataFromDB(formData);

        if (data == null) {
            return null;
        }

        data.setStatus(FormStatus.ADDONS);
        data.setAdditionalData(formData.getAdditionalData());
        data.setUpdatedAt(new Date());
        data.setCandidateDetails(formData.getCandidateDetails());

        String id = data.getId();

        updateData(data, false);

        return id;
    }

    @Override
    public FormData getLatestRecord(String merchantId, String customerId, String candidateId) {
        Query query = new Query();
        Criteria criteria = Criteria.where("merchantId").is(merchantId)
                .and("customerId").is(customerId)
                .and("candidateId").is(candidateId);
        query.addCriteria(criteria);
        query.with(Sort.by("createdAt").descending());

        return mongoOperations.findOne(query, FormData.class);
    }

    @Override
    public FormData getRecord(String refId) {
        Query query = new Query();
        Criteria criteria = Criteria.where("_id").is(refId);
        query.addCriteria(criteria);

        return mongoOperations.findOne(query, FormData.class);
    }

    private FormData getFormDataFromDB(FormData formData) {
        FormData data = null;

        if (formData.getId() != null) {
            data = getRecord(formData.getId());

        } else if (formData.getCustomerId() != null
                && formData.getMerchantId() != null
                && formData.getCandidateId() != null) {
            data = getLatestRecord(formData.getMerchantId(), formData.getCustomerId(), formData.getCandidateId());
        }

        return data;
    }

    public boolean validateFormDataRequest(FormData formData) {
        return formData.getId() != null
                || (formData.getMerchantId() != null
                && formData.getCustomerId() != null
                && formData.getCandidateId() != null);
    }

    private FormData getFormDataBasedOnCriteriaAndSort(
            Criteria criteria, List<String> projectionKeys, String sortField) {
        Query query = new Query();
        query.addCriteria(criteria);
        if (sortField != null) {
            query.with(new Sort(Sort.Direction.DESC, sortField));
        }
        projectionKeys.forEach(k -> query.fields().include(k));
        query.limit(1);
        List<FormData> formData = mongoOperations.find(query, FormData.class);
        return formData.isEmpty() ? null : formData.get(0);
    }

    private Criteria createBaseCriteria(
            @NonNull String merchantId,
            @NonNull String customerId,
            @NonNull String candidateId) {
        return Criteria
                .where("merchantId").is(merchantId)
                .and("customerId").is(customerId)
                .and("candidateId").is(candidateId);
    }

    @Override
    public LatestFormData getCurrentOpenAndLastPaidFormDetails(
            @NonNull String merchantId, @NonNull String customerId,
            @NonNull String candidateId, @NonNull List<String> keys) {

        String paymentFieldName = "formFulfilment.orderId";

        Criteria lastOrderCriteria = createBaseCriteria(merchantId, customerId, candidateId)
                .and(paymentFieldName).exists(true);
        //                .and(paymentFieldName).ne(null);

        //                .andOperator(
        //                        Criteria.where(paymentFieldName).exists(true),
        //                        Criteria.where(paymentFieldName).ne(null)
        //                );

        Criteria unpaidOrderCriteria = createBaseCriteria(merchantId, customerId, candidateId)
                .and(paymentFieldName).exists(false);

        // todo: check this flow
        //                .orOperator(
        //                        Criteria.where(paymentFieldName).exists(false),
        //                        Criteria.where(paymentFieldName).is(null)
        //                );

        return new LatestFormData(
                getFormDataBasedOnCriteriaAndSort(unpaidOrderCriteria, keys, "updatedAt"),
                getFormDataBasedOnCriteriaAndSort(lastOrderCriteria, keys, "formFulfilment.createdDate")
        );
    }

}
